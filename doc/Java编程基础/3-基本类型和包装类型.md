## 八大基本类型

|  基本类型   | 字节大小 | 数据范围 | 默认值 |
|  ----  | ----  | ---- | ----- |
| byte | 1 | -128 ~ 127 | 0 |
| short | 2 | -2^15 ~ 2^15-1 | 0 |
| int | 4 | -2^31 ~ 2^31-1 | 0 |
| long | 8 | -2^63 ~ 2^63-1 | 0L |
| float | 4 | -3.4e38 ~ 3.4e28 | 0.0f|
| double | 8 | -1.7e308 ~ 1.7e308 | 0.0|
| char | 2 | '\u0000' ~ '\uFFFF' | '\u0000' |
| boolean | 1 | true or false | false |

#### 对于整数类型，为什么负数比正数多一个？
以4bit为例，一共可以表示16个数，在计算机中，使用补码编码法来表示整数，正数和负数的关系为
```
// 0是自然数，不是整数也不是负数。
正数 = 取反(负数) + 1
负数 = 取反(正数-1)
```
按照上面的公式，可以得出以下结果

| 正数   | 二进制 | 负数 | 二级制 |
|  ----  | ----  | ---- | ----- |
| 0 | 0000 | 0 | 0000 |
| 1 | 0001 | -1 | 1111 |
| 2 | 0010 | -2 | 1110 |
| 3 | 0011 | -3 | 1101 |
| 4 | 0100 | -4 | 1100 |
| 5 | 0101 | -5 | 1011 |
| 6 | 0110 | -6 | 1010 |
| 7 | 0111 | -7 | 1001 |
| 8 | 无法表示 | -8 | 1000 |

4bit可以表示16个数，0占了一个，剩下15个，所以正数和负数的个数肯定是相等的。在4bit这个例子中，多余下来的位数为 `1000`，由于最高位1表示负数，所以只能用来表示-8。因此，负数就比正数多了一个。

将这个分析推广到`n bit`，整数的负数总是比整数多一个，为 `-2^(n-1)`。


### 基本类型转换
一般来讲，数据范围小的向数据范围大的可以触发自动类型转换；数据范围大的向数据范围小的转换可能发生数据截断，所以需要手动强制类型转换。

> boolean 不能与其他基本类型发生转换


#### 自动类型转换

- byte：short int long float double
- short：int long float double
- int：long float double
- float：double
- char：int long float double

> 因为char不表示负数，数据范围比short大，所以不能自动转换为short

```
public class PrimitiveType {
    public static void main(String[] args) {
        char ch = 'a';
        //需要强转，否则编译不通过
        short s = (short) ch;
        int s = ch;
    }
}
```

#### 强制类型转换
```
public class PrimitiveType {
    public static void main(String[] args) {
        double d = 1.0;
        float f = (float) d;
        
        long l = 111L;
        int i = (int) l;
    }
}
```

## 包装类型
在 `Java` 中，每种基本类型都有对应的包装类型。

基本类型与包装类型之间可以进行转换，这种转换可以是隐式的，也可以是显式的，前者专业的叫法为**自动装箱和拆箱**。

### 显式转换
以 `int` 为例
#### 显式将基本类型转换为包装类
```
int i = 123;
Integer integer1 = Integer.valueOf(i); 
Integer integer2 = new Integer(i); 
```
#### 显式将包装类转换为基本类型
```
i = integer1.intValue();
```

### 隐式转换
其实隐形转换是`Java`提供的对显式转换的语法糖。
#### 自动装箱
```
int i = 123;
Integer integer1 = i;
```
#### 自动拆箱
```
i = integer1;
```

#### 什么时候触发自动装箱
将基本类型赋值给包装类型的时候，包括参数传递

#### 什么时候触发自动拆箱

1. 将包装类赋值给基本类型，包括参数传递
2. 包装类参与算数运算
3. 包装类参与关系运算：`> < >= <=`
4. 包装类参与关系运行：`==`，且一方是基本类型

## 基本类型与包装类型的比较

### 基本类型的优点

1. 读写效率高：变量对应的内存即为存储数据本身
2. 节省空间：包装类型对象占用的空间大于基本类型

> 在一切皆为对象的`Java`中，这两个优点，保留基本类型被保留的主要原因。

### 包装类型的优点
提高了丰富的方法，可以更方便的实现复杂功能。

### 什么时候使用基本类型，什么时候使用包装类？
首选基本类型，毕竟性能好。在一些需要设置没有业务意义的值的场景，推荐使用包装类，`null`值可以满足需求，比如 `Java Web` 开发中的数据类 `VO BO PO Entity Domain` 中属性的定义。

### Java 是否兼顾一切皆对象和性能，抛弃基本类型？
可以。Java可以只提供包装类型，在编译阶段把包装类型转换为基本类型，之所以不这么做的原因是考虑向前兼容吧。

> 事实上，新兴的运行在JVM之上的语言，`Groovy、Scala` 已经这么做了。


