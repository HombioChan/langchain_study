## 序言
在学习 [哈希表](../hblog/数据结构和算法/16-哈希表.md) 的时候，我们知道，哈希表设计时主要考虑3个问题

1. 哈希函数
2. 动态扩容和缩容
3. 哈希冲突

在`Java`中，`HashMap`是哈希表的一个标准实现，本节就来看看它是如何处理这3个问题的。


## 哈希函数
设键为 `key`，数组长度为 `n`，一般的哈希函数如下
```
index = hash(key) % n
```
### hash算法
```
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
`hashCode()`定义在`Object`类中，根据对象在内存中的地址来计算哈希值。

#### 上面的`hash()`，为什么不直接返回h?
为了充分利用哈希信息，使最终计算得到的数组下标尽可能随机。

数组的长度n一般小于 `2^32`，而hash值为`int`类型，长度为4个字节，所以在求模运算中，hash值的高16位信息会丢失。理论上讲，想要得到的数组下标越随机，那么参与运算的信息应该越多，为了不能让高16位的信息丢失，所以便有了 `h ^ (h>>>16)`。

#### key == null 的情况
当key==null，哈希值为0，对应的数组下标为0。

### 求模
基于性能考虑，`HashMap`使用逻辑与运算符`&`替代了`%`，算法如下
```
index = hash(key) & (n-1)
```
为了起到和 `%` 运算一样的效果，这里的n是有要求的，必须是2的倍数。

#### 如何保证 n 是2的倍数
创建 `HashMap` 时，如果指定了 `initialCapacity`，那么内部会通过这个函数计算得到大于`initialCapacity`的第一个是2的倍数的数。
```
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

## 动态扩容与缩容
### 动态扩容
`HashMap`内部维护了一个阈值`threshold`，每次往调用`put()`方法添加元素成功后，会判断容器中键值对的个数是否超过了`threshold`，如果超过，就触发动态扩容，申请一个大小为原来2倍的数组，并将原来数组的元素，一个个搬迁到新数组中。

#### 如何搬迁，搬迁的逻辑是怎么样的？

设旧数组的长度为 `oldCap`，在`JDK8中`，搬迁逻辑如下
1. 遍历容器元素，记遍历元素为node，数组下标为i
2. 如果node.hash & oldCap == 0，元素的数组下标保证不变，即newIndex = i
3. 否则，newIndex = i + oldCap

这其实是一种优化手段，达到的效果是和 `node.hash & (2 * oldCap - 1)` 是一样的。

#### 扩容策略
一次性扩容

#### 为什么是添加成功再检查是否扩容？
在`JDK8`中，如果是先扩容的话，需要再遍历一次链表或者查找二叉树，相对于添加成功之后扩容，性能下降。


### 动态缩容

## 哈希冲突
`HashMap`使用的哈希冲突解决方法是了链地址法，`JDK8`中，当链表达到一定长度后，会将链表树化为红黑树。

### treeify
在`JDK8`中，当链表达到一定长度后，链表树会进化为红黑树。

#### 触发时机
当数组长度`n >= 64` 时，如果链表长度 `>= 8`，就发触发树化，将链表转换成红黑树。

当数组长度`n < 64`，即使链表长度`>=8`，也不会发生树化，而是会触发扩容操作，试图通过扩容，将长链表拆分为短链表。这样做的原因是，数据量小的情况下，扩容比树化简单高效。

### untreeify
当红黑树中的节点减少到一定区间后，就会退化成链表，有以下两种情况

1. 容器删除元素
2. 发生动态扩容

