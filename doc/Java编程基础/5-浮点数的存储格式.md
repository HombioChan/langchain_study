## 序言
计算机中，整数使用的存储格式是补码，实数的存储格式标准是 `IEE754`。

### 定点数表示法
实数可以划分为两个部分：整数和小数。分别将整数和小数部分转化为二进制，然后中间用`.`分割即可。

例如 12.375 的二进制表示为：1100.011。

整数部分的使用补码规则，小数的转化规则如下
```
0.375 x 2 = 0.75  余 0 剩 0.75
0.75 x 2 = 1.5    余 1 剩 0.5
0.5 x 2 = 1.0     余 1 剩 0 结束
```

#### 存储格式
定点数存储法：最高位表示符号位，固定多少位存整数，多少位存小数。

比如32位，可以分为 1位符号位 20位整数位 11位小数位。

这种表示方法最大的缺点：浪费空间，当存放纯整数或者纯小数时，由于位数固定，即使数据截断，也不能利用其他位数。

### 浮点数表示法
即 `IEEE754` 标准：(-1) * S * M * 2^E

- S：符号位，1表示负数，表示正数
- M：有效数字，固定结构：1.xxx，整数有效位固定为1，所以存储时只存小数位后的数字
- E：指数，`[-126, 127]`，存储时+127，范围为 `[1, 254]`

#### 存储格式
单精度：1(S) 8(E) 23(M)

双精度：1(S) 11(E) 52(M)

以单精度为例，12.375的二进制表示法为：1100.011，那么浮点数表示法为：1.100011 * 2^3，即

- S=0
- E=3+127 = 130 = 1000 0010
- M=100011

所以单精度的存储结构为：0 10000010 10001100000000000000000

#### 一些特殊的浮点值

- 浮点数0：E=0，表示M的有效整数位为0
- 正无穷：S=0，E=255，M=0
- 负无穷：S=1，E=255，M=0
- NaN：E=255，M!=0

#### 数据范围
最大值：S=0，E=127，M=21个1，即 1.1(21) * 2 ^ 127

最小值：S=1， E=127，M=21个1，即 -1.1(21) * 2 ^ 127

转化为十进制大概是：`[3.4E38, -3.4E38]`

> 32位一共可以表示2^32个数，然而实数集合是无限的，当把无限的集合映射到有限的集合，必然会发生冲突，也就是存在多个实数的浮点存储格式是一样的。



## 拓展思考
### 单精度浮点数是否可以准确表示所有的整数？
以4字节的`int`类型为例，分为两种情况

1. 整数补码位数 <= 24，没发生溢出，能够准确表示的整数范围是 `[-2^24-1, 2^24-1]`
2. 整数补码位数 > 24，发生溢出，且溢出的都是0，设 x 不属于`[-2^24-1, 2^24-1]`，那么这部分可以准确表示整数为 `x & 0xFFFF FF00`

```
//25位，溢出的为0，可以准确表示
int a1 = 0b1_0000_0000_0000_0000_0000_0000;
System.out.println(a1); //输出： 16777216
float f1 = a1;
System.out.printf("%.11f\n", f1) //输出：16777216.00000000000;

//25位，溢出的为1，丢失1，不能准确表示
int a2 = 0b1_0000_0000_0000_0000_0000_0001;
System.out.println(a2); //输出： 16777217
float f2 = a2;
System.out.printf("%.11f\n", f2); //输出：16777216.00000000000;
//套用公式，如果 a2 != a2 & 0xFFFFFF00，说明是不可以准确表示的
System.out.println(a2 & 0xFFFFFF00); //输出：16777216

```

### 浮点数可以表示的最小正数是多少？
二进制表示法：1.00000000000000000000000 * 2^-126

- S = 1
- E = 1
- M = 1
