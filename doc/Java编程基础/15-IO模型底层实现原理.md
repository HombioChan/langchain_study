## 序言 
[Java的I/O模型](14-Java的IO模型.md) 里说过，Java的I/O模型是一个抽象层，具体的实现由操作系统提供，而不同的操作系统实现也不太一样。

不过流程大同小异，本节讲讲 I/O 模型的在Linux的底层实现。

### I/O 读写流程
```
        用户态          |    内核态         |   硬件
-------------------------------------------------------------------
读 <- 应用程序缓冲区  <-copy-- 内核读缓冲区 <-copy-- I/O设备（磁盘，网卡等）
写 -> 应用程序缓冲区  --copy-> 内核写缓冲区 --copy-> I/O设备（磁盘，网卡等）
```

首先，读写 I/O设备 之前，建立连接，在Linux，一切皆文件，所以会返回一个文件描述符。

#### 读操作流程

1. 应用程序调用 `Java I/O` 类库中的读函数发起读请求
2. `Java I/O`类库会发起系统调用 `read()`，此时CPU状态从用户态装换到了内核态
3. 操作系统检查内核读缓冲区中是否有足够的数据，有的话直接拷贝到应用缓存区
4. 否则，操作系统从I/O设备拷贝数据到内核缓存区，然后再拷贝到应用程序缓存区，此时CU状态从内核态装换到了用户态

#### 写操作流程

1. 应用程序调用 `Java I/O` 类库中的读函数发起写请求
2. `Java I/O`类库会发起系统调用 `write()`，此时CPU状态从用户态装换到了内核态
3. 操作系统检查内核写缓冲区中是否有足够的空间写数据，有的话把数据从应用缓存区拷贝到内核写缓存区，这个时候，写操作就完成了
4. 操作系统会根据一定的规则，在某个时刻，将写缓存中的数据一并写入I/O设备，当然也可以直接发起系统调用触发立即写入磁盘。

### 总结
一次 I/O 读写会触发一次系统调用，两次上下文切换，两次数据拷贝。


### 拓展问题
#### 内核已经有了缓存，那 `java.io` 库为什么还提高支持缓存的装饰器类？
减少系统调用次数，可一定程度提高读写 I/O 效率。

以`BufferedInputstream`读操作为例，它的内部默认缓存大小为8192字节，和内核的读缓存默认大小一致，每次发起系统调用会读取8192字节，当用户读取的字节经常小于8192字节时，可以直接命中应用程序缓存，无需发起系统调用。如果是使用普通的`InputStream`，那么每次读取都会发起一次系统调用。

系统调用时比较耗时的，减少系统调用意味着提高了程序效率。


#### 什么是用户态，什么是内核态？
用户态和内核态是CPU的两种运行状态，当CPU处于用户态时，只能运行有限的机器指令，当CPU处于内核态时，可以运行所有的机器指令。

#### 为什么区分用户态和内核态？
保护计算机：操作系统不允许应用程序直接操作计算机硬件资源，只能通过发起系统调用间接操作。

#### 系统调用、函数调用、上下文切换的关系
系统调用本质上就是函数调用，不同于普通的函数调用，系统调用会发生上下文切换，在内核空间重新开辟一个函数调用栈。

上下文切换是比较耗时的，具体如下

1. 寄存器的保存和恢复耗时：操作系统会在内核空间重新开辟函数调用栈，所以包保存和恢复的寄存器现场比较多
2. CPU缓存失效：用户空间和内核空间显然是不相邻的，所以CPU缓存会失效
